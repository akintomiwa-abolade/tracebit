package dev.io.tracebit.service.impl;


import com.itextpdf.text.*;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.pdf.*;
import dev.io.tracebit.entity.AuditLog;
import dev.io.tracebit.repository.AuditLogRepository;
import dev.io.tracebit.service.AuditLogExportService;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVPrinter;
import org.jfree.data.category.DefaultCategoryDataset;
import org.springframework.stereotype.Service;

import org.jfree.chart.ChartFactory;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.category.DefaultCategoryDataset;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.io.ByteArrayOutputStream;

import java.io.OutputStreamWriter;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class AuditLogExportServiceImpl implements AuditLogExportService {

    private final AuditLogRepository auditLogRepository;

    private List<AuditLog> getFilteredLogs(String userId, String action, LocalDateTime from, LocalDateTime to) {
        return auditLogRepository.findByCreatedAtBetween(from, to)
                .stream()
                .filter(log -> (userId == null || log.getUserId().toLowerCase().contains(userId.toLowerCase())))
                .filter(log -> (action == null || log.getAction().toLowerCase().contains(action.toLowerCase())))
                .collect(Collectors.toList());
    }

    @Override
    public void exportToCsv(String userId, String action, LocalDateTime from, LocalDateTime to, HttpServletResponse response) {
        try {
            List<AuditLog> logs = getFilteredLogs(userId, action, from, to);
            response.setContentType("text/csv");
            response.setHeader("Content-Disposition", "attachment; filename=audit-logs.csv");

            CSVPrinter csvPrinter = new CSVPrinter(new OutputStreamWriter(response.getOutputStream()), CSVFormat.DEFAULT
                    .withHeader("User ID", "Action", "Target", "IP", "Device", "Location", "Created At"));

            for (AuditLog log : logs) {
                csvPrinter.printRecord(
                        log.getUserId(),
                        log.getAction(),
                        log.getTarget(),
                        log.getMeta().getIp(),
                        log.getMeta().getDevice(),
                        log.getMeta().getLocation(),
                        log.getCreatedAt()
                );
            }

            csvPrinter.flush();
        } catch (Exception e) {
            throw new RuntimeException("Error generating CSV export", e);
        }
    }

    @Override
    public void exportToPdf(String userId, String action, LocalDateTime from, LocalDateTime to, HttpServletResponse response) {
        try {
            List<AuditLog> logs = getFilteredLogs(userId, action, from, to);

            response.setContentType("application/pdf");
            response.setHeader("Content-Disposition", "attachment; filename=audit-logs.pdf");

            Document document = new Document(PageSize.A4.rotate());
            PdfWriter writer = PdfWriter.getInstance(document, response.getOutputStream());

            writer.setPageEvent(new PdfPageEventHelper() {
                Font watermarkFont = new Font(Font.FontFamily.HELVETICA, 52, Font.BOLD, new BaseColor(230, 230, 230));

                @Override
                public void onEndPage(PdfWriter writer, Document document) {
                    // Watermark
                    ColumnText.showTextAligned(writer.getDirectContentUnder(),
                            Element.ALIGN_CENTER,
                            new Phrase("TRACEBIT REPORT", watermarkFont),
                            (document.right() - document.left()) / 2 + document.leftMargin(),
                            (document.top() + document.bottom()) / 2,
                            45);

                    // Footer
                    Phrase footer = new Phrase("Generated by Tracebit · Page " + writer.getPageNumber() + " · https://tracebit.dev",
                            FontFactory.getFont(FontFactory.HELVETICA_OBLIQUE, 9, BaseColor.GRAY));
                    ColumnText.showTextAligned(writer.getDirectContent(),
                            Element.ALIGN_CENTER, footer,
                            (document.right() - document.left()) / 2 + document.leftMargin(),
                            document.bottom() - 10, 0);
                }
            });

            document.open();

            // Title
            Font titleFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 18, BaseColor.DARK_GRAY);
            Paragraph title = new Paragraph("Audit Logs Export Report", titleFont);
            title.setAlignment(Element.ALIGN_CENTER);
            document.add(title);
            document.add(Chunk.NEWLINE);

            // Chart Summary: Action Distribution
            Image chartImage = createActionDistributionChart(logs);
            chartImage.scaleToFit(500, 300);
            chartImage.setAlignment(Element.ALIGN_CENTER);
            document.add(chartImage);
            document.add(Chunk.NEWLINE);

            // Filter Summary Section
            Font labelFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 11);
            Font valueFont = FontFactory.getFont(FontFactory.HELVETICA, 10);
            PdfPTable summaryTable = new PdfPTable(2);
            summaryTable.setWidths(new float[]{2f, 5f});
            summaryTable.setWidthPercentage(50);
            summaryTable.setSpacingAfter(15f);

            addSummaryRow(summaryTable, "User ID:", userId != null ? userId : "—", labelFont, valueFont);
            addSummaryRow(summaryTable, "Action:", action != null ? action : "—", labelFont, valueFont);
            addSummaryRow(summaryTable, "Date Range:", from + " to " + to, labelFont, valueFont);
            addSummaryRow(summaryTable, "Export Format:", "PDF", labelFont, valueFont);

            document.add(summaryTable);

            // Table setup
            PdfPTable table = new PdfPTable(7);
            table.setWidthPercentage(100);
            table.setSpacingBefore(5f);
            table.setSpacingAfter(10f);
            table.setHeaderRows(1);

            String[] headers = {"User ID", "Action", "Target", "IP", "Device", "Location", "Created At"};

            // Header styling
            Font headerFont = FontFactory.getFont(FontFactory.HELVETICA_BOLD, 11, BaseColor.WHITE);
            BaseColor headerColor = new BaseColor(0, 121, 107);

            for (String header : headers) {
                PdfPCell cell = new PdfPCell(new Phrase(header, headerFont));
                cell.setBackgroundColor(headerColor);
                cell.setPadding(6f);
                table.addCell(cell);
            }

            // Data rows with alternating background color
            boolean alternate = false;
            for (AuditLog log : logs) {
                BaseColor bg = alternate ? BaseColor.WHITE : new BaseColor(245, 245, 245);
                alternate = !alternate;

                table.addCell(styledCell(log.getUserId(), bg));
                table.addCell(styledCell(log.getAction(), bg));
                table.addCell(styledCell(log.getTarget(), bg));
                table.addCell(styledCell(log.getMeta().getIp(), bg));
                table.addCell(styledCell(log.getMeta().getDevice(), bg));
                table.addCell(styledCell(log.getMeta().getLocation(), bg));
                table.addCell(styledCell(String.valueOf(log.getCreatedAt()), bg));
            }

            document.add(table);
            document.close();

        } catch (Exception e) {
            throw new RuntimeException("Error generating PDF export", e);
        }
    }

    private void addSummaryRow(PdfPTable table, String label, String value, Font labelFont, Font valueFont) {
        PdfPCell labelCell = new PdfPCell(new Phrase(label, labelFont));
        labelCell.setBorder(Rectangle.NO_BORDER);
        labelCell.setPaddingBottom(5f);
        table.addCell(labelCell);

        PdfPCell valueCell = new PdfPCell(new Phrase(value, valueFont));
        valueCell.setBorder(Rectangle.NO_BORDER);
        valueCell.setPaddingBottom(5f);
        table.addCell(valueCell);
    }

    private PdfPCell styledCell(String text, BaseColor bgColor) {
        PdfPCell cell = new PdfPCell(new Phrase(text != null ? text : "", FontFactory.getFont(FontFactory.HELVETICA, 10)));
        cell.setBackgroundColor(bgColor);
        cell.setPadding(5f);
        return cell;
    }

    private Image createActionDistributionChart(List<AuditLog> logs) throws Exception {
        Map<String, Long> actionCounts = logs.stream()
                .collect(Collectors.groupingBy(AuditLog::getAction, Collectors.counting()));

        DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        actionCounts.forEach((action, count) -> dataset.addValue(count, "Actions", action));

        JFreeChart chart = ChartFactory.createBarChart(
                "Audit Action Summary",
                "Action",
                "Count",
                dataset,
                PlotOrientation.VERTICAL,
                false, true, false
        );

        chart.setBackgroundPaint(Color.white);
        chart.getTitle().setPaint(new Color(50, 50, 50));

        BufferedImage bufferedImage = chart.createBufferedImage(500, 300);
        ByteArrayOutputStream chartStream = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "png", chartStream);
        return Image.getInstance(chartStream.toByteArray());
    }


}

